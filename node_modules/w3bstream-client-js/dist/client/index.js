var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import axios from "axios";
class W3bstreamClientError extends Error {
    constructor(message) {
        super(message);
        this.name = "W3bstreamClientError";
    }
}
export class W3bstreamClient {
    constructor(_url, _apiKey, options) {
        this._url = _url;
        this._apiKey = _apiKey;
        this._DATA_PUSH_EVENT_TYPE = "DA-TA_PU-SH";
        this._worker = null;
        this._publishIntervalMs = 1000;
        this._batchSize = 10;
        this._maxQueueSize = 0;
        this.queue = [];
        if (!_url) {
            throw new W3bstreamClientError("url is required");
        }
        if (!_apiKey) {
            throw new W3bstreamClientError("api key is required");
        }
        this._url = _url;
        this._apiKey = _apiKey;
        this._batchSize = (options === null || options === void 0 ? void 0 : options.batchSize) || this._batchSize;
        this._publishIntervalMs =
            (options === null || options === void 0 ? void 0 : options.publishIntervalMs) || this._publishIntervalMs;
        this._maxQueueSize = (options === null || options === void 0 ? void 0 : options.maxQueueSize) || this._maxQueueSize;
        if (options === null || options === void 0 ? void 0 : options.enableBatching) {
            this._startWorker();
        }
    }
    enqueueAndPublish(header, payload) {
        if (!this._worker) {
            throw new W3bstreamClientError("attempted to enqueue without enabling batching");
        }
        if (this._maxQueueSize > 0 && this.queue.length >= this._maxQueueSize) {
            return false;
        }
        this._validateHeader(header);
        const payloadObj = this._buildPayload(header, payload);
        this.addToQueue(payloadObj);
        return true;
    }
    publishDirect(header, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            this._validateHeader(header);
            const payloadObj = this._buildPayload(header, payload);
            return this._publish(payloadObj, header.timestamp);
        });
    }
    stop() {
        this._publishQueue();
        if (this._worker) {
            clearInterval(this._worker);
            this._worker = null;
        }
    }
    _startWorker() {
        this._worker = setInterval(() => __awaiter(this, void 0, void 0, function* () { return yield this._publishQueue(); }), this._publishIntervalMs);
    }
    _publishQueue() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.queue.length > 0) {
                const payload = this.takeFromQueue(this._batchSize);
                try {
                    yield this._publish(payload);
                }
                catch (e) {
                    console.error(e);
                    console.log("requeueing: ", payload);
                    this.addToQueue(payload);
                }
            }
        });
    }
    takeFromQueue(length) {
        return this.queue.splice(0, length);
    }
    addToQueue(payloadObj) {
        this.queue.push(...payloadObj);
    }
    _validateHeader(header) {
        if (!header.device_id) {
            throw new W3bstreamClientError("device id is required");
        }
    }
    _buildPayload(header, payload) {
        const { device_id, event_type = "DEFAULT", timestamp = this._currentTimestamp(), } = header;
        const _payload = payload instanceof Buffer ? payload.toString() : JSON.stringify(payload);
        return [
            {
                device_id,
                event_type,
                payload: _payload,
                timestamp,
            },
        ];
    }
    _buildUrl(timestamp = this._currentTimestamp()) {
        return `${this._url}?eventType=${this._DATA_PUSH_EVENT_TYPE}&timestamp=${timestamp}`;
    }
    _currentTimestamp() {
        return Date.now();
    }
    _publish(payload, timestamp) {
        const url = this._buildUrl(timestamp);
        return axios.post(url, payload, {
            headers: {
                Authorization: `Bearer ${this._apiKey}`,
                "Content-Type": "application/json",
            },
        });
    }
}
